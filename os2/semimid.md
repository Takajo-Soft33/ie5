# オペレーティングシステムⅡ 2019年度 前期中間試験

## 1 語句に関する問題
　プロセスの起動と終了が繰り返されるうちに使用できない小さなメモリの領域がたくさんできる。この領域は_メモリフラグメント_と呼ばれる。_メモリフラグメント_を解消するために、実行中のプロセスをメモリ上で移動し詰め合わせを行う。これは_メモリコンパクション_と呼ばれる。_メモリコンパクション_を可能にするハードウェア機構であるリロケーションレジスタは、プロセスの_ロードアドレス（Base）_と_大きさ（Limit）_を記録するレジスタである。プロセスの実行を開始する際に値が設定される。プロセスの実行中は_ロードアドレス（Base)_とCPUの出力するアドレスの和がメモリのアドレスになる。リロケーションレジスタは、プロセスの動的再配置機構としても_メモリ保護_機構としても働く。
　セグメンテーションでは、セグメントサイズを自由に設定できるので_内部_フラグメントが生じない。しかし、セグメントの間に_外部_フラグメントが生じる。セグメントを物理メモリに配置する際は、セグメントサイズ_以上_の_連続_した領域が必要になる。セグメントが物理メモリより大きくなることが_できない_。
　ページングでは、使用するメモリ領域の大きさがページサイズの整数倍でない場合に_内部_フラグメントを生じる。_内部_フラグメントを小さくするにはページサイズを_小さく_すればいいが、これによりページテーブルが_大きく_なる。ページングはメモリ管理のハードウェアである_MMU_によるp→f変換により実現される。p→f変換はメモリ上に置いた_ページテーブル_を参照することによってなされる。変換を行うたびにメモリ上の_ページテーブル_を参照すると時間がかかるので、一度変換した結果は_TLB_にキャッシュしておく。通常、_ページテーブル_の大きさは_仮想_アドレス空間の大きさに比例して大きくなる。_ページテーブル_が大きくなりすぎないように、_多段_の_ページテーブル_を使用するシステムと逆引き_ページテーブル_を使用するシステムがある。逆引き_ページテーブル_の大きさは_物理_アドレス空間の大きさに比例する。
　ページングを用いて仮想空間を実現することができる。フレームが割り付けられていないページをプロセスがアクセスすると、_page fault（ページ不在割り込み）_が発生し制御がオペレーティングシステムに移る。オペレーティングシステムがフレームを割り付け、ページをフレームに読み込み、プロセスを再開する。このような、ページが必要になった時点でページを読み込む方式を_デマンドページング_と呼ぶ。
　forkシステムコールを実行する際に、親プロセスの仮想アドレス空間の内容を子プロセスのそれにコピーする必要がある。フレームをコピーするのではなくフレームを親子プロセスで共有することで、コピーによるオーバーヘッドを小さくすることが可能である。内容が変更されないフレームは単に共有すれば良い。内容が変更されるフレームは、どちらかのプロセスが内容を書き換えようとした時点でコピーを作る。この方式を_copy on write（COW）_と呼ぶ。
　プログラムの実行中、一部のページにアクセスが集中することがある。短い時間に、連続したアドレスに配置されたページにアクセスが集中するのは、プログラムのメモリアクセスに_空間_的局所性があるためである。また、あるページに着目すると、ある時間にアクセスが集中するのは、プログラムのメモリアクセスに_時間_的局所性があるためである。ある時間にアクセスされるページの集合は、その時間における_ワーキングセット_と呼ばれる。_ワーキングセット_が大きくなりすぎてメモリに入りきらなくなると、swap-in/swap-outを繰り返しシステムの性能が急激に低下する_スラッシング_が発生する。

## 2 可変区画方式
　110KiBの空き領域を利用可能な、メモリ管理を可変区画方式で行なっているシステムで、すでに40KiB,10KiB,30KiB,20KiBの領域が割り付けられているとします。メモリマップは以下の通りです。
　<small>注意：OSカーネルは0番地から配置されているものとします。また、以下の間で領域を分割してメモリ割り付けする場合は、0番地に近い側の領域を使用するものとします。</small>

<div class="flex">
![](semimid-2-a.png)


![semimid-2-b.png]
</div>

以下の操作を順に行った時のメモリマップを、ファーストフィット方式とベストフィット方式を用いた場合について示しなさい。なお、メモリマップには使用中の領域だけ書き込みなさい。

1. 40KiB, 20KiBの領域を解放後、10KiBの領域を割り付けた。
<div class="flex">
ファーストフィット
_![](semimid-2-1-ff.png)_


ベストフィット
_![](semimid-2-1-bf.png)_
</div>

2. 前の操作に続いて、30KiBの領域を解放後、20KiBの領域を割り付けた。
<div class="flex">
ファーストフィット
_![](semimid-2-2-ff.png)_


ベストフィット
_![](semimid-2-2-bf.png)_
</div>

3. 前の操作に続いて、10KiBの領域を割り付けた後、さらに30KiBの領域を割り付けた。
<div class="flex">
ファーストフィット
_![](semimid-2-3-ff.png)_


ベストフィット
_![](semimid-2-3-bf.png)_
</div>

## 3 セグメンテーション
1. 物理メモリ空間のメモリマップが次の図のようになっている時、下のセグメントテーブルを完成しなさい。なお、格納された値に意味がない項目には-を記入しなさい。

![](semimid-3.png)

| No | v | ... | B | L |
| --- | --- | --- | --- | --- |
| 0 | _0_ | ... | _-_ | _-_ |
| 1 | _1_ | ... | _0x1000_ | _0x1000_ |
| 2 | _0_ | ... | _-_ | _-_ |
| 3 | _1_ | ... | _0x4000_ | _0x3000_ |

2. 次の仮想アドレスが変換される物理アドレスを答えなさい。なお、変換できない場合は「変換不可」と答えなさい。

a. 0x0:0x1234
  _変換不可_
b. 0x1:0x1234
  _変換不可_
c. 0x3:0x1234
  _0x5234_

## 4 ページング
　バイトごとにアドレス付され、仮想アドレス空間の大きさが2<sup>26</sup>バイト、物理アドレス空間の大きさが2<sup>32</sup>バイト、２段のページテーブルを用いるシステムあるとします。仮想アドレスは次のようにページ番号（p, q）とページ内アドレス（w）に分割されます。

![](semimid-4-a.png)

1. このシステムのページサイズを答えなさい。
  _2<sup>10</sup>バイト_
2. フレーム番号が何ビットになるか答えなさい。
  _22ビット_
3. ページテーブルの１エントリが４バイトの時、１段目のページテーブルの大きさをバイト単位で答えなさい。
  _1024バイト_
4. ２段目のページテーブルを格納するために必要なフレーム数は最大で何フレームになるか答えなさい、なお、２段目のページテーブルの１エントリも４バイトとする。
  _256フレーム_
5. ページテーブルが次のような内容の時、次の仮想アドレスが変換される物理アドレスを１６進数で答えなさい。なお、２段目のページテーブルは第３フレームに置かれているものとします。また、変換できない場合は「変換不可能」と記しなさい。
  ![](semimid-4-5.png)
  a. 0x0000412
    _変換不可能_
  b. 0x0040412
    _0x00001412_
  c. 0x0040812
    _変換不可能_


## 5 仮想アドレス空間の配置
　次の図は、ページングを用いるUNIXシステムの仮想アドレス空間のメモリマップ例である。
![](semimid-5-a.png)
1. 各部の名称を語群の記号で答えなさい。
  __語群__: （あ）初期化データ（data）, （い）スタック, （う）ヒープ, （え）非初期化データ（bss）, （お）プログラム(text)
  | a | b | c | d | e |
  | --- | --- | --- | --- | --- |
  | _お_ | _あ_ | _え_ | _う_ | _い_ |

2. 各ページに最適なメモリ保護モード（RWX)を答えなさい。
  | ページ0 | ページ1 | ページ2 | ページ3 | ページ4 |
  | --- | --- | --- | --- | --- |
  | _R-X_ | _R--_ | _RW-_ | _RW-_ | _RW-_ |

<style>
.em {
  visibility: hidden;
}
.em:hover {
  visibility: visible;
}
.flex {
  display: flex;
}
</style>
